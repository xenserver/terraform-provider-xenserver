package xenserver

import (
	"context"
	"errors"
	"regexp"
	"slices"
	"strings"

	"xenapi"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

type vifResourceModel struct {
	Network     types.String `tfsdk:"network_uuid"`
	Device      types.String `tfsdk:"device"`
	VIF         types.String `tfsdk:"vif_ref"`
	MAC         types.String `tfsdk:"mac"`
	OtherConfig types.Map    `tfsdk:"other_config"`
}

var vifResourceModelAttrTypes = map[string]attr.Type{
	"network_uuid": types.StringType,
	"device":       types.StringType,
	"vif_ref":      types.StringType,
	"mac":          types.StringType,
	"other_config": types.MapType{ElemType: types.StringType},
}

func VIFSchema() map[string]schema.Attribute {
	return map[string]schema.Attribute{
		"network_uuid": schema.StringAttribute{
			MarkdownDescription: "Network UUID to attach to VIF.",
			Required:            true,
		},
		"device": schema.StringAttribute{
			MarkdownDescription: "Order in which VIF backends are created by [XAPI](https://github.com/xapi-project/xen-api), default to be `\"0\"`." + "<br />" +
				"If this value is changed, the VIF will be recreated.",
			Required: true,
			Validators: []validator.String{
				stringvalidator.RegexMatches(
					regexp.MustCompile(`^[0-9]+$`),
					"Input is not a valid device number",
				),
			},
		},
		"vif_ref": schema.StringAttribute{
			Computed: true,
		},
		"mac": schema.StringAttribute{
			MarkdownDescription: "MAC address of the VIF, default to be a random MAC address generated by XenServer." +
				"\n\n-> **Note:** `mac` is not allowed to be updated.",
			Optional: true,
			Computed: true,
			Validators: []validator.String{
				// match MAC address regex
				stringvalidator.RegexMatches(
					regexp.MustCompile(`^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$`),
					"Input is not a valid MAC address",
				),
			},
		},
		"other_config": schema.MapAttribute{
			MarkdownDescription: "The additional configuration of the network interface, default to be `{}`.Find more details in [advanced-settings-for-network-interfaces](https://docs.xenserver.com/en-us/xenserver/developer/sdk-guide/xs-api-extensions#advanced-settings-for-network-interfaces).",
			ElementType:         types.StringType,
			Optional:            true,
			Computed:            true,
		},
	}
}

func setVIFDefaults(ctx context.Context, vif *vifResourceModel) {
	// Work around for https://github.com/hashicorp/terraform-plugin-framework/issues/726
	if vif.MAC.IsUnknown() {
		vif.MAC = types.StringValue("")
	}

	if vif.OtherConfig.IsUnknown() {
		var diags diag.Diagnostics
		vif.OtherConfig, diags = types.MapValueFrom(ctx, types.StringType, map[string]string{})
		if diags.HasError() {
			tflog.Debug(ctx, "unable to set VIF other config")
		}
	}
}

func createVIF(ctx context.Context, vif vifResourceModel, vmRef xenapi.VMRef, session *xenapi.Session) error {
	var vifRef xenapi.VIFRef
	networkRef, err := xenapi.Network.GetByUUID(session, vif.Network.ValueString())
	if err != nil {
		return errors.New(err.Error())
	}

	setVIFDefaults(ctx, &vif)

	otherConfig := make(map[string]string)
	diags := vif.OtherConfig.ElementsAs(ctx, &otherConfig, false)
	if diags.HasError() {
		return errors.New("unable to get VIF other config")
	}

	vifRecord := xenapi.VIFRecord{
		VM:      vmRef,
		Network: networkRef,
		Device:  vif.Device.ValueString(),
		MAC:     vif.MAC.ValueString(),
		// from XAPI code, the mtu is actually works when set in vif.other_config instead of vif.MTU, give it a default value here
		MTU:              1500,
		OtherConfig:      otherConfig,
		LockingMode:      xenapi.VifLockingModeNetworkDefault,
		MACAutogenerated: vif.MAC.ValueString() == "",
	}

	vifRef, err = xenapi.VIF.Create(session, vifRecord)
	if err != nil {
		return errors.New(err.Error())
	}

	vmPowerState, err := xenapi.VM.GetPowerState(session, vmRef)
	if err != nil {
		return errors.New(err.Error())
	}

	if vmPowerState == xenapi.VMPowerStateRunning {
		if err = xenapi.VIF.Plug(session, vifRef); err != nil {
			return errors.New(err.Error())
		}
	}

	return nil
}

func createVIFs(ctx context.Context, session *xenapi.Session, vmRef xenapi.VMRef, data vmResourceModel) error {
	elements := make([]vifResourceModel, 0, len(data.NetworkInterface.Elements()))
	diags := data.NetworkInterface.ElementsAs(ctx, &elements, false)
	if diags.HasError() {
		return errors.New("unable to get Network Interface elements")
	}

	// removed existing VIFs in VM template
	existingVIFs, err := xenapi.VM.GetVIFs(session, vmRef)
	if err != nil {
		return errors.New(err.Error())
	}

	for _, vif := range existingVIFs {
		if err = xenapi.VIF.Destroy(session, vif); err != nil {
			return errors.New(err.Error())
		}
	}

	for _, vif := range elements {
		if err = createVIF(ctx, vif, vmRef, session); err != nil {
			return errors.New(err.Error())
		}
	}
	return nil
}

func vifResourceModelUpdateCheck(plan vifResourceModel, state vifResourceModel) error {
	if plan.MAC.ValueString() != "" && !plan.MAC.Equal(state.MAC) {
		return errors.New(`"network_interface.mac" doesn't expected to be updated`)
	}
	return nil
}

// updateVIF updates the VIFs in the VM based on the plan and state, the logic is similar to updateVBDs
func updateVIFs(ctx context.Context, plan vmResourceModel, state vmResourceModel, vmRef xenapi.VMRef, session *xenapi.Session) error {
	// Get VIFs from plan and state
	planVIFs := make([]vifResourceModel, 0, len(plan.NetworkInterface.Elements()))
	diags := plan.NetworkInterface.ElementsAs(ctx, &planVIFs, false)
	if diags.HasError() {
		return errors.New("unable to get VIFs in plan data")
	}

	stateVIFs := make([]vifResourceModel, 0, len(state.NetworkInterface.Elements()))
	diags = state.NetworkInterface.ElementsAs(ctx, &stateVIFs, false)
	if diags.HasError() {
		return errors.New("unable to get VIFs in state data")
	}

	var err error
	planVIFsMap := make(map[string]vifResourceModel)
	for _, vif := range planVIFs {
		planVIFsMap[vif.Device.String()+vif.Network.String()] = vif
	}

	stateVIFsMap := make(map[string]vifResourceModel)
	for _, vif := range stateVIFs {
		stateVIFsMap[vif.Device.String()+vif.Network.String()] = vif
	}

	vmState, err := xenapi.VM.GetPowerState(session, vmRef)
	if err != nil {
		return errors.New(err.Error())
	}

	// Destroy VIFs that are not in plan, destroy VIFs first to avoid error "DEVICE_ALREADY_EXISTS"
	for networkUUID, stateVIF := range stateVIFsMap {
		if _, ok := planVIFsMap[networkUUID]; !ok {
			vifRef := xenapi.VIFRef(stateVIF.VIF.ValueString())
			if vmState == xenapi.VMPowerStateRunning {
				allowedOps, err := xenapi.VIF.GetAllowedOperations(session, vifRef)
				if err != nil {
					return errors.New(err.Error())
				}
				if slices.Contains(allowedOps, xenapi.VifOperationsUnplug) {
					tflog.Debug(ctx, "---> Unplug VIF when VM is running.")
					err = xenapi.VIF.Unplug(session, vifRef)
					if err != nil {
						return errors.New(err.Error())
					}
				}
			}
			tflog.Debug(ctx, "---> Destroy VIF:	"+stateVIF.VIF.String())
			err = xenapi.VIF.Destroy(session, vifRef)
			if err != nil {
				if !strings.Contains(err.Error(), "HANDLE_INVALID") {
					return errors.New(err.Error())
				}
				tflog.Debug(ctx, "HANDLE_INVALID: VIF already been destroyed.")
			}
		}
	}

	// Create VIFs that are in plan but not in state, Update VIFs if already exists and attributes changed
	for deviceNetwork, planVIF := range planVIFsMap {
		stateVIF, ok := stateVIFsMap[deviceNetwork]
		if !ok {
			tflog.Debug(ctx, "---> Create VIF with Network: "+planVIF.Network.String()+" <---")
			err = createVIF(ctx, planVIF, vmRef, session)
			if err != nil {
				return err
			}
		} else {
			setVIFDefaults(ctx, &planVIF)

			tflog.Debug(ctx, "---> Update VIF "+stateVIF.VIF.String()+" <---")
			err := vifResourceModelUpdateCheck(planVIF, stateVIF)
			if err != nil {
				return err
			}

			if !planVIF.OtherConfig.Equal(stateVIF.OtherConfig) {
				otherConfig := make(map[string]string)
				diags := planVIF.OtherConfig.ElementsAs(ctx, &otherConfig, false)
				if diags.HasError() {
					return errors.New("unable to get network_interface.other_config")
				}

				err = xenapi.VIF.SetOtherConfig(session, xenapi.VIFRef(stateVIF.VIF.ValueString()), otherConfig)
				if err != nil {
					return errors.New(err.Error())
				}
			}
		}
	}

	return nil
}
